---
title: 75.Sort Colors
---

## 一、题意
题目链接: [75.Sort Colors](https://leetcode.com/problems/sort-colors/)
### 1.Description
【输入】
给定一个长度为n的整数数组。
其中所有的元素取值都是集合[0, 1, 2]的。
【输出】
将这个数组进行排序，且按照0 -> 1 -> 2这个顺序从前到后排列。

### 2.Example
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

### 3.Corner Case
1.n <= 1, 直接return即可。
2.要求就地排序，即空间复杂度为O(1)。
3.一个直接的想法是：统计0，1，2的个数，然后再重写nums数组。
显然这样需要遍历两次nums数组。
4.找一个one-pass的方法。

## 二、题解
### Solution-1：Three Pointers 
1.用三个指针p0，cur，p2。
初始化：
p0 = 0
cur = 0
p2 = n - 1
分别代表：
p0: 元素'0'可能出现的位置，p0之前的位置上都已经全部放上'0'了。
cur: 当前考察的位置。
p2: 元素'2'可能出现的位置，p2之后的位置上都已经全部放上'2'了。

2.循环开始：cur从0开始。
循环结束：cur == p2是最后一次循环。

3.过程：
如果当前cur位置上的元素是'2'的话，将其与p2位置上的元素交换。p2--；cur保持不动，继续判断交换过来的这个值。
如果当前cur位置上的元素是'0'的话，将其与p0位置上的元素交换。p0++；cur向后移动一位（因为当前和p0交换过来的这个值，一定是0或者1，不可能是2）.
    如果是0的话，不需要重新考虑。
    如果是1的话，也不需要重新考虑。
如果当前cur位置上的元素是'1'的话，cur++即可。

时间复杂度：O(n)
空间复杂度：O(1)

2.Code(https://leetcode.com/submissions/detail/286030421/)
