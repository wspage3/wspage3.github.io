---
title: 链表
categories: 
- [数据结构与算法]
tags: 
- Linked List
---

## 一、单链表（Singly Linked List）

### 0、简介
1. 单链表中的每个结点记录了：我的值(val)是什么、我的后继结点是谁；

2. 根据以上特性，对于任一已知结点node来说，可以：
以O(1)的时间复杂度，求出node的后继结点；
以O(n)的时间复杂度，求出node的前驱结点；

3. 在竞赛/笔试中，考虑到程序的性能，常常使用静态链表，即用数组模拟链表；
主要原因在于：若在C++中使用动态链表，则每个结点的创建消耗大量的时间，即new的过程；
常见用途：实现邻接表，用于存储树、图；

<!-- more -->

### 1、实现
1. 动态单链表，经典实现：结构体 + 指针
```C++
// C
struct ListNode {
    int val;
    struct ListNode* next;
};
 
// C++
struct ListNode {
    int val;
    ListNode* next;
};
```

2. 静态单链表，数组模拟：
```C++
const int N = 100000 + 10;
int val[N]; // 记录当前结点的val
int ne[N];  // 记录当前结点的后继节点的索引
int head; // 记录head结点的索引
int available; // 记录下一个空闲的结点的索引
 
int main() {
    // ...
}
```

### 2、基本操作
1. 【添加头结点】：在链表头添加一个结点x（非空）：
x指向head当前指向的结点；
刷新head，指向x；

2. 【添加非头结点】：给定任一结点node（非空、可头、可尾），在其后面添加一个结点x（非空）：
x指向node的后继结点；
node指向x；

3. 【删除头结点】：删除链表的头节点x（非空）；
刷新head，指向x的后继结点；

4. 【删除非头结点】：给定任一结点node（非空、可头、非尾），删除其后面的结点x（非空）：
node指向x的后继节点；

### 3、相关题目
编号|题目|题意|概要|状态
:-:|:-:|:-:|:-:|:-:
01|[AcWing-826-单链表](https://www.acwing.com/problem/content/828/)|1. 在链表头插入一个结点；<br>2. 给定结点k，在其后面插入一个结点；<br>3. 给定结点k，删除其后面的结点；|数组模拟单链表：<br>head不占数组空间，记录头节点的索引，-1表示NULL；|II
02|[Leetcode-002-Add Two Numbers](https://wspage3.github.io/2020/05/31/Linked%20List/Leetcode-002-Add%20Two%20Numbers/)|1. 给定两个非空单链表l1、l2，分别代表一个非负整数；<br>2. 链表头结点为个位，尾结点为最高位；<br>3. 计算这两个整数的和，并以上述单链表的形式返回；<br>|模拟加法运算：<br>个位对齐；若有进位，保存下来；<br>创建局部变量dummy方便返回实际的头结点；|II
03|[Leetcode-445.Add Two Numbers II](https://wspage3.github.io/2020/12/15/Linked%20List/Leetcode-445-Add%20Two%20Numbers%20II/)|1. 给定两个非空单链表l1、l2，分别代表一个非负整数；<br>2. 链表头结点为最高位，尾结点为个位；<br>3. 计算这两个整数的和，并以上述单链表的形式返回；<br>|栈 + 模拟加法运算：<br>将l1、l2中数字依次压入栈s1、s2；<br>每次取栈顶两个元素相加；<br>生成一个新结点后，插入已有链表头部；<br>|II
04|[Leetcode-237-Delete Node in a Linked List](https://wspage3.github.io/2019/12/29/Linked%20List/Leetcode-237-Delete%20Node%20in%20a%20Linked%20List/)|1. 给定单链表中的一个结点node，node非尾结点，且合法非空；<br>2. 删除node；<br>|狸猫换太子：<br>将node换成node的后继结点（结构体直接用'='赋值）；<br>删除后继结点（delete释放内存）；<br>|II
05|[Leetcode-206-Reverse Linked List](https://wspage3.github.io/2019/12/29/Linked%20List/Leetcode-206-Reverse%20Linked%20List/)|1. 给定一个单链表的头结点head；<br>2. 将其反转，返回反转后的头结点；<br>|递归：<br>确定递归结束条件：NULL或单结点；<br>先递归子链表，记录答案newHead；<br>再将当前结点接到末尾；<br>最后返回newHead；<br>迭代：<br>head结点遍历；<br>cur结点是当前考察的结点；<br>pre结点是已经反转好的头结点；<br>|II
06|[Leetcode-092-Reverse Linked List II](https://wspage3.github.io/2019/12/29/Linked%20List/Leetcode-092-Reverse%20Linked%20List%20II/)|1. 给定一个单链表的头结点head；<br>2. 给定一个区间范围[m, n]；<br>3. 将子链表[m, n]反转，返回此时单链表的头结点；<br>4. 本题中的编号，从1开始；且m、n均合法；<br>|分解：<br>设置虚拟头结点dummy，方便处理m为1的情况；<br>tail指向Node(m - 1)；<br>start指向Node(m)；<br>迭代法反转：反转后，pre、cur均指向Node(n)，head指向Node(n + 1)；<br>拼接：tail向后接cur(或pre)，start向后接head；<br>|II
07|[Leetcode-025-Reverse Nodes in k-Group](https://wspage3.github.io/2020/09/21/Linked%20List/Leetcode-025-Reverse%20Nodes%20in%20k-Group/)|1. 给定一个单链表的头结点head；<br>2. 给定一个正整数k：1 <= k <= n；<br>3. 对单链表中的结点k个一组进行反转，返回新链表的头结点；<br>当结点数不足k个时，不进行反转；<br>4. O(1)的空间复杂度；<br>|模拟：<br>T(n)、S(1)；<br>1. 统计结点数n；<br>2. 进行n / k轮循环；<br>3. 每轮循环中，取k个结点进行反转；<br>4. 返回dummy.next；<br>|II
08|[Leetcode-876-Middle of the Linked List](https://wspage3.github.io/2020/04/29/Linked%20List/Leetcode-876-Middle%20of%20the%20Linked%20List/)|1. 给定一个单链表的头结点head，head非空；<br>2. 输出链表的中间结点；<br>3. 如果中间结点有两个，输出右边那个；<br>|暴力(Two-round)：<br>先遍历一次，求出链表的长度n；<br>head往后移动n / 2次即可；<br>双指针(One-round)：<br>slow、fast同时从head出发；<br>当fast为NULL或者fast->next为NULL的时候，返回slow即可；<br>Follow-up：若中间结点有两个，输出左边那个：<br>(n - 1) / 2；<br>slow、fast同时从虚拟头结点出发；<br>|II
09|[Leetcode-019-Remove Nth Node From End of List](https://wspage3.github.io/2019/12/30/Linked%20List/Leetcode-019-Remove%20Nth%20Node%20From%20End%20of%20List/)|1. 给定一个单链表的头结点head；<br>2. 给定一个整数k，1 <= k <= n；<br>3. 删除单链表的倒数第k个结点，返回此时的头结点；<br>|暴力(Two-round)：<br>先遍历一次，求出链表的长度n；<br>设置虚拟头结点dummy，tail指向dummy；<br>tail向后移动n - k次后，指向target的前驱结点；<br>删除target；<br>双指针(One-round)：<br>设置虚拟头结点dummy；<br>slow、fast同时从dummy出发；<br>fast先向后移动k + 1次；<br>slow、fast同时向后移动，直到fast为NULL；<br>此时slow指向target的前驱结点；<br>删除target；<br>|II
10|[《剑指Offer》-022-链表中倒数第k个节点](https://wspage3.github.io/2020/06/28/Linked%20List/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B-022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/)|1. 给定一个单链表的头结点head；<br>2. 给定一个整数k；<br>3. 返回单链表的倒数第k个结点；<br>|双指针(One-round)：<br>设置虚拟头结点dummy；<br>slow、fast同时从dummy出发；<br>fast先向后移动k次；<br>slow、fast同时向后移动，直到fast为NULL；<br>此时slow指向target；<br>返回target；<br>本题需要判断k是否在[1, n]内，否则可能会有运行时错误；<br>|II
11|[Leetcode-234-Palindrome Linked List](https://wspage3.github.io/2020/09/03/Linked%20List/Leetcode-234-Palindrome%20Linked%20List/)|1. 给定一个单链表的头结点head；<br>2. 判断该单链表是否为一个回文串；<br>3. 若head为NULL、或者head为单结点时，认为是回文串；<br>4. O(n)的时间复杂度、O(1)的空间复杂度；<br>|双指针 + 栈：<br>T(n)、S(n)；<br>双指针 + Reverse：<br>T(n)、S(1)；<br>|II
12|[Leetcode-143-Reorder List](https://wspage3.github.io/2020/09/14/Linked%20List/Leetcode-143-Reorder%20List/)|1. 给定一个单链表的头结点head；<br>2. 将单链表按照：L0→Ln→L1→Ln-1→L2→Ln-2→…重新排列；<br>|双指针 + Reverse：<br>T(n)、S(1)；<br>|II
13|[Leetcode-141-Linked List Cycle](https://wspage3.github.io/2020/09/04/Linked%20List/Leetcode-141-Linked%20List%20Cycle/)|1. 给定一个单链表的头结点head；<br>2. 判断该单链表中是否存在环路；<br>3. 要求O(1)的空间复杂度；<br>|双指针：<br>T(n)、S(1)；<br>slow、fast从head出发；<br>slow跳一步、fast跳两步；<br>若相遇，存在环路；<br>|II
14|[Leetcode-142-Linked List Cycle II](https://wspage3.github.io/2020/09/04/Linked%20List/Leetcode-142-Linked%20List%20Cycle%20II/)|1. 给定一个单链表的头结点head；<br>2. 找出入环点，若没有，返回NULL；<br>3. 要求O(1)的空间复杂度；<br>|双指针：<br>T(n)、S(1)；<br>slow、fast从head出发；<br>slow跳一步、fast跳两步；<br>若相遇，存在环路；<br>slow从head出发、fast继续从相遇点出发；<br>再次相遇点就是入环点；<br>|II
15|[Leetcode-160-Intersection of Two Linked Lists](https://wspage3.github.io/2020/09/14/Linked%20List/Leetcode-160-Intersection%20of%20Two%20Linked%20Lists/)|1. 给定两个单链表的头结点l1、l2；<br>2. 找出两个链表的交点，若没有，返回NULL；<br>3. 要求O(n)的时间复杂度，O(1)的空间复杂度；<br>|双指针：<br>T(n)、S(1)；<br>p从l1出发，q从l2出发；<br>同时向后跳一步；<br>判断是否在同一个结点；<br>若为NULL，则从另外一个链表头开始继续遍历；<br>|II
16|[Leetcode-021-Merge Two Sorted Lists](https://wspage3.github.io/2020/09/07/Linked%20List/Leetcode-021-Merge%20Two%20Sorted%20Lists/)|1. 给定两个单链表，头结点分别为l1、l2，两个单链表都是有序的（非降序）；<br>2. 将这两个单链表合并成一个单链表，同时保持有序的特点，返回头结点；<br>|双指针：<br>T(n)、S(1)；<br>|II
17|[Leetcode-023-Merge k Sorted Lists](https://wspage3.github.io/2020/09/07/Linked%20List/Leetcode-023-Merge%20k%20Sorted%20Lists/)|1. 给定k个单链表（数组形式），单链表都是有序的（非降序）；<br>2. 将这k个单链表合并成一个单链表，同时保持有序的特点，返回头结点；<br>|Min Heap：<br>T(N * log k)、S(k)；<br>Sort：<br>T(N * log N)、S(N)；<br>Merge one by one：<br>T(N * k)、S(1)；<br>Divide and Conquer：<br>T(N * log k)、S(1)；<br>|II
18|[Leetcode-083-Remove Duplicates from Sorted List](https://wspage3.github.io/2020/09/08/Linked%20List/Leetcode-083-Remove%20Duplicates%20from%20Sorted%20List/)|1. 给定一个单链表，头结点为head，单链表是有序的（非降序）；<br>2. 将单链表中的重复元素去除，使得继续保持有序的情况下：每个元素出现一次；<br>|双指针：<br>T(n)、S(1)；<br>1. tail指向head；<br>2. cur从head->next出发，直到为NULL；<br>3. 依次考虑cur是否是某一批的第一个结点（cur->val == tail->val）：是的话，接在tail后面；否则的话，删除cur；<br>|II
19|[Leetcode-082-Remove Duplicates from Sorted List II](https://wspage3.github.io/2020/09/08/Linked%20List/Leetcode-082-Remove%20Duplicates%20from%20Sorted%20List%20II/)|1. 给定一个单链表，头结点为head，单链表是有序的（非降序）；<br>2. 将单链表中的重复元素去除，使得继续保持有序的情况下：原先出现一次的元素，继续出现一次；原先出现若干次的元素，将其全部删除；<br>|双指针：<br>T(n)、S(1)；<br>1. slow指向某一批的第一个结点，fast指向下一批的第一个结点；<br>2. 判断slow、fast之间的距离是否大于1；<br>3. 使用虚拟结点dummy，tail初始化指向它，如果有符合题意的结点，将其接在tail后面；<br>4. fast后移的同时，free；最后考虑slow是否需要free；<br>|II
20|[Leetcode-203-Remove Linked List Elements](https://wspage3.github.io/2020/09/08/Linked%20List/Leetcode-203-Remove%20Linked%20List%20Elements/)|1. 给定一个单链表，头结点为head；<br>2. 给定一个整数val；<br>3. 将单链表中值为val的结点删除，返回新链表的头结点；<br>|双指针：<br>T(n)、S(1)；<br>1. tail指向dummy；<br>2. cur从head出发，直到为NULL；<br>3. 依次考虑cur是否需要删除（cur->val == val）：不需要的话，接在tail后面；否则的话，删除cur；<br>|II
21|[Leetcode-328-Odd Even Linked List](https://wspage3.github.io/2020/09/15/Linked%20List/Leetcode-328-Odd%20Even%20Linked%20List/)|1. 给定一个单链表，头结点为head；L1→…→Ln-1→Ln；<br>2. 将单链表按照：L1→L3→L5→...→L2→L4→L6→...重新排列，返回新链表的头结点；<br>3. 要求O(n)的时间复杂度，O(1)的空间复杂度；<br>|双指针：<br>T(n)、S(1)；<br>1. odd指向第一段链表的尾结点（初始化head）；<br>2. even指向第二段链表的尾结点（初始化head->next）；<br>3. 由于odd始终在even前面，需要对even进行判断；<br>4. n为奇数时，even为NULL，break；<br>n为偶数时，even指向原链表尾结点，break；<br>5. 最后将evenHead拼接到odd后面即可；<br>|II
22|[Leetcode-024-Swap Nodes in Pairs](https://wspage3.github.io/2020/09/15/Linked%20List/Leetcode-024-Swap%20Nodes%20in%20Pairs/)|1. 给定一个单链表，头结点为head；L1→…→Ln-1→Ln；<br>2. 将单链表按照：L2→L1→L4→L3→...重新排列，返回新链表的头结点；<br>|双指针(Iterative)：<br>T(n)、S(1)；<br>1. 创建虚拟头结点dummy；<br>2. tail指针指向结果链表的尾结点，初始化指向dummy；<br>3. head指针用于遍历：当剩余结点个数不足2时，结束循环；<br>4. odd指针指向head，even指针指向head->next；<br>5. 进行拼接；<br>6. 更新tail、head：用于下一轮循环；<br>Recursive：<br>T(n)、S(n)；<br>1. 循环结束条件：子链表结点数不足2；<br>2. head指向左边结点，n指向右边结点；<br>3. head指向子链表的反转结果，n指向head；<br>4. 返回n即可；<br>|II
23|[Leetcode-061-Rotate List](https://wspage3.github.io/2020/05/07/Linked%20List/Leetcode-061-Rotate%20List/)|1. 给定一个单链表，头结点为head；给定一个非负整数k；<br>2. 将单链表向右“旋转”k次，返回新链表的头结点；<br>“旋转”：将最后一个结点移动到链表的开头；<br>|双指针：<br>T(n)、S(1)；<br>1. 找出尾结点tail，以及结点数n；<br>2. 对k模n处理，判断k是否为0；<br>3. 找出新链表的头结点ans，以及ans的前驱结点preAns；<br>4. 拼接，返回ans；<br>|II
24|[Leetcode-725-Split Linked List in Parts](https://wspage3.github.io/2020/05/07/Linked%20List/Leetcode-725-Split%20Linked%20List%20in%20Parts/)|1. 给定一个单链表，头结点为root；给定一个正整数k；<br>2. 将单链表分成k个片段，每个片段都是一个小链表；<br>3. 以一维数组的形式返回，数组每个元素是一个片段的头结点；<br>4. 每一片段的长度尽可能的相等：任意两个片段的长度差不得大于1；<br>前一片段的长度不得小于后一片段的长度；<br>需要保持有序：k个片段的顺序需要与其在list中出现的顺序一致；<br>|模拟：<br>T(n)、S(1)；<br>1. 统计结点数n；<br>2. 每个片段的基础长度len = n / k；<br>3. 剩余n % k个结点，分配给前n % k个片段，每个片段一个结点；<br>4. cur指向每个片段的头结点，pre指向每个片段的尾结点；<br>|II
25|[Leetcode-138-Copy List with Random Pointer](https://wspage3.github.io/2020/09/16/Linked%20List/Leetcode-138-Copy%20List%20with%20Random%20Pointer/)|1. 给定一个“复杂”单链表，头结点为head；<br>复杂：有一个额外的指针random，指向链表中的某个结点，或者指向NULL；<br>2. 对其进行“深拷贝”，返回新链表的头结点；<br>|哈希表：<br>T(n)、S(n)；<br>1. cur从head开始遍历，到NULL结束：申请n个新结点，并维护新旧结点的关联关系；<br>2. cur从head开始遍历，到NULL结束：处理m[cur]的next域以及random域；<br>3. 返回m[head]；<br>串联、拆分：<br>T(n)、S(1)；<br>1. cur从head开始遍历，到NULL结束：申请n个新结点，并将新旧结点串联起来（1, 1', 2, 2', ...）；<br>2. cur从head开始遍历，到NULL结束：处理cur->next的random域；<br>3. 拆分成两条短链表：使用虚拟结点dummy，将新节点逐一接在tail后面；<br>4. 返回dummy.next；<br>|II
26|[Leetcode-147-Insertion Sort List](https://wspage3.github.io/2020/09/17/Linked%20List/Leetcode-147-Insertion%20Sort%20List/)|1. 给定一个单链表，头结点为head；<br>2. 对单链表进行插入排序，返回排序后的头结点；<br>3. 对原链表进行就地操作，不申请额外的空间存储链表；<br>|插入排序：<br>T(n ^ 2)、S(1)；<br>1. dummy后接head，head后接NULL；<br>2. cur从head->next出发，直到为NULL；<br>3. 对于任一cur，pos从&dummy出发，使得pos->next是第一个满足条件的结点(pos->next->val >= cur->val)；<br>4. 也就是说：如果cur已经出现，则cur出现在重复元素的最左侧；<br>5. 将cur插入到pos和pos->next中间；<br>|II
27|[Leetcode-148-Sort List](https://wspage3.github.io/2020/09/18/Linked%20List/Leetcode-148-Sort%20List/)|1. 给定一个单链表，头结点为head；<br>2. 对单链表进行排序，返回排序后的头结点；<br>3. O(n * log n)的时间复杂度，O(1)的空间复杂度；<br>|插入排序：<br>T(n ^ 2)、S(1)；<br>快速排序（自顶向下，递归）：<br>T(n ^ log n)、S(log n)；<br>归并排序（自顶向下，递归）：<br>T(n ^ log n)、S(log n)；<br>归并排序（自下而上，迭代）：<br>T(n ^ log n)、S(1)；<br>|II
28|[Leetcode-086-Partition List](https://wspage3.github.io/2020/09/18/Linked%20List/Leetcode-086-Partition%20List/)|1. 给定一个单链表，头结点为head；<br>2. 给定一个整数x；<br>3. 对单链表进行重排列，使得：链表左边元素均小于x，右边元素均大于等于x；<br>4. 同时，左右两边内部元素的相对顺序，需要保持；<br>|快速排序Partition过程（双指针）：<br>T(n)、S(1)；<br>1. 使用两个虚拟头结点lDummy、rDummy；<br>|II

## 二、双链表（Doubly Linked List）

### 0、简介
1. 双链表中的每个结点记录了：我的值(val)是什么、我的后继结点是谁、我的前驱结点是谁；

2. 根据以上特性，对于任一已知结点node来说，可以：
以O(1)的时间复杂度，求出node的后继结点；
以O(1)的时间复杂度，求出node的前驱结点；

3. 常见用途：优化某些问题；

### 1、实现
1. 动态双链表，经典实现：结构体 + 指针
```C++
// C
struct ListNode {
    int val;
    struct ListNode* next;
    struct ListNode* prev;
};
 
// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode* prev;
};
```

2. 静态双链表，数组模拟：
```C++
const int N = 100000 + 10;
int val[N]; // 记录当前结点的val
int pr[N];  // 记录当前结点的前驱节点的索引
int ne[N];  // 记录当前结点的后继节点的索引
int head; // 记录head哨兵结点的索引，固定为0
int tail; // 记录tail哨兵结点的索引，固定为1
int available; // 记录下一个空闲的结点的索引，从2开始
 
int main() {
    // ...
}
```

### 2、基本操作
1. 【添加头结点】：在链表头添加一个结点x（非空）：
转化为操作2：给定head，在其右边添加结点x；

2. 【添加非头结点】：给定任一结点node（非空、可头、可尾），在其右边添加一个结点x（非空）：
x向后指向node的后继结点；x向前指向node；
node指向x；x的后继结点向前指向x；

3. 【删除结点】：给定任一结点node（非空、可头、可尾），删除它：
node的前驱结点向后指向node的后继结点；
node的后继结点向前指向node的前驱结点；

### 3、相关题目
题目|题意|概要|状态
:-:|:-:|:-:|:-:
[AcWing-827-双链表](https://www.acwing.com/problem/content/829/)|1. 删除第k个结点；——上述操作3 <br>2. 在链表头，插入一个结点；——上述操作1 <br>3. 在链表尾，插入一个结点；——可转化为上述操作2：在pr[tail]右边，插入一个结点<br>4. 给定结点k，在其后面插入一个结点；——上述操作2<br>5. 给定结点k，在其前面插入一个结点；——可转化为上述操作2：在pr[k]右边，插入一个结点<br>|数组模拟双链表：<br>head、tail为两哨兵，占用数组空间，索引为0和1；|II
