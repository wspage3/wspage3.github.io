---
title: 《程序员面试金典》-0305-栈排序
categories: 
- [《程序员面试金典》]
- [数据结构与算法]
tags: 
- Design
- Stack
- Monotonous Stack
- Sort
---

## 一、题意

### 0、题目链接
[《程序员面试金典》-0305-栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

### 1、Description
【输入】
无；
【输出】
设计一个数据结构"有序栈"，具有以下操作：
1.push(x) -- 将x入栈，同时要保证栈的有序性（栈顶元素最小）；
2.pop() -- 将栈顶元素抛出；若栈空，不能出现异常；
3.peek() -- 返回栈顶元素；若栈空，返回-1；
4.isEmpty() -- 判断栈是否为空；
【要求】
除了栈s外，只能使用另外一个栈辅助；
不能使用其它的数据结构；

### 2、Example
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]

<!-- more -->

### 3、Corner Case
1. 题目数据不能保证：pop()、peek()、isEmpty()这三个操作调用的时候，栈一定为非空；

2. 栈中的元素数目在[0, 5000]范围内。

## 二、题解

### 0、思考
1. 类似于单调栈；

### 1、Solution-1：Using Two Stacks
1. push(x)的时候：
将ans中小于x的元素依次放入help中；
将x放入ans中；
将help中的元素再返回到ans中；

2. 每加入一个元素到ans后，help都为空。
最终所有的元素存放在ans中，且栈顶元素最小。

3. Code(https://leetcode-cn.com/submissions/detail/79197068/)
AC
时间复杂度：push-O(n)；其余三个操作-O(1)；
空间复杂度：O(n)
```C++
class SortedStack {
private:
    stack<int> ans;
    stack<int> help;
public:
    SortedStack() {
 
    }
    
    void push(int val) {
        while (!ans.empty() && ans.top() < val) {
            help.push(ans.top());
            ans.pop();
        }
        ans.push(val);
        while (!help.empty()) {
            ans.push(help.top());
            help.pop();
        }
    }
    
    void pop() {
        if (ans.empty()) {
            return;
        }
        ans.pop();
    }
    
    int peek() {
        if (ans.empty()) {
            return -1;
        }
        return ans.top();
    }
    
    bool isEmpty() {
        return ans.empty();
    }
};
```

### 2、双栈排序
1. 给定一个长度为n的数组numbers，将其看作是一个栈：numbers[0]为栈顶，numbers[n - 1]为栈底；
对其进行排序；

2. 过程如下：
将numbers转化为一个栈nums；
从nums中拿出一个元素，将其放入辅助栈help中。最终所有的元素都放入了help中；
将help中的元素读出来，存在数组ans中，返回即可；

3. Code(https://www.nowcoder.com/profile/876389328/codeBookDetail?submissionId=79307114)
AC
时间复杂度：O(n * n)
空间复杂度：O(n)
```C++
class TwoStacks {
public:
    vector<int> twoStacksSort(vector<int> numbers) {
        int n = numbers.size();
        if (n <= 1) {
            return numbers;
        }
         
        stack<int> nums;
        for (int i = n - 1; i >= 0; i--) {
            nums.push(numbers[i]);
        }
         
        stack<int> help;
         
        while (!nums.empty()) {
            int x = nums.top();
            nums.pop();
             
            while (!help.empty() && x > help.top()) {
                nums.push(help.top());
                help.pop();
            }
            help.push(x);
        }
         
        vector<int> ans(n, -1);
        for (int i = n - 1; i >= 0; i--) {
            ans[i] = help.top();
            help.pop();
        }
        return ans;
    }
};
```
